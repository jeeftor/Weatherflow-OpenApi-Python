# coding: utf-8

"""
    WeatherFlow Tempest API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Contact: jforare@weatherflow.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing import overload, Optional, Union, Awaitable

from typing_extensions import Annotated
from pydantic import Field, StrictInt, StrictStr

from typing import Optional

from weatherflow_openapi.models.observation_set import ObservationSet
from weatherflow_openapi.models.station_observation import StationObservation

from weatherflow_openapi.api_client import ApiClient
from weatherflow_openapi.api_response import ApiResponse
from weatherflow_openapi.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ObservationsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @overload
    async def get_observations_by_device_id(self, device_id : Annotated[StrictInt, Field(..., description="ID of device")], day_offset : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC")] = None, time_start : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, time_end : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Use format=csv to return a CSV response type.")] = None, **kwargs) -> ObservationSet:  # noqa: E501
        ...

    @overload
    def get_observations_by_device_id(self, device_id : Annotated[StrictInt, Field(..., description="ID of device")], day_offset : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC")] = None, time_start : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, time_end : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Use format=csv to return a CSV response type.")] = None, async_req: Optional[bool]=True, **kwargs) -> ObservationSet:  # noqa: E501
        ...

    @validate_arguments
    def get_observations_by_device_id(self, device_id : Annotated[StrictInt, Field(..., description="ID of device")], day_offset : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC")] = None, time_start : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, time_end : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Use format=csv to return a CSV response type.")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[ObservationSet, Awaitable[ObservationSet]]:  # noqa: E501
        """Get Observations for a Single Device  # noqa: E501

        Get observations for a Device(Air,Sky,Tempest) by using the device_id as the key.  You can find device_id values in the response from the Stations service  You can get observations using several filters (latest, time range, day offset).      Use the \"type\" value to determine the layout of the observations values.  The \"obs\" object is an array of observations.  Each observation is an array of observation values (see layout below).<br><br>**Air**  (type=\"obs_air\")<br>Observation Layout<br>0 - Epoch (seconds UTC)<br>1 - Station Pressure (MB)<br>2 - Air Temperature (C)<br>3 - Relative Humidity (%)<br>4 - Lightning Strike Count<br>5 - Lightning Strike Average Distance (km)<br>6 - Battery (volts)<br>7 - Report Interval (minutes)<br><br>**Sky** (type=\"obs_sky\")<br>Observation Layout<br>0 - Epoch (seconds UTC)<br>1 - Illuminance (lux)<br>2 - UV (index)<br>3 - Rain Accumulation (mm)<br>4 - Wind Lull  (m/s)<br>5 - Wind Avg (m/s)<br>6 - Wind Gust (m/s)<br>7 - Wind Direction (degrees)<br>8 - Battery (volts)<br>9 - Report Interval (minutes)<br>10 - Solar Radiation (W/m^2)<br>11 - Local Day Rain Accumulation (mm)<br>12 - Precipitation Type (0 = none, 1 = rain, 2 = hail, 3 = rain + hail (experimental))<br>13 - Wind Sample Interval (seconds)<br>14 - <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> (mm)<br>15 - Local Day <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>16 - Precipitation Analysis Type (0 = none, 1 = Rain Check with user display on, 2 = Rain Check with user display off)<br><br>**Tempest** (type=\"obs_st\")<br>Observation Layout<br>0 - Epoch (Seconds UTC)<br>1 - Wind Lull  (m/s)<br>2 - Wind Avg (m/s)<br>3 - Wind Gust (m/s)<br>4 - Wind Direction (degrees)<br>5 - Wind Sample Interval (seconds)<br>6 - Pressure (MB)<br>7 - Air Temperature (C)<br>8 - Relative Humidity (%)<br>9 - Illuminance (lux)<br>10 - UV (index)<br>11 - Solar Radiation (W/m^2)<br>12 - Rain Accumulation (mm)<br>13 - Precipitation Type (0 = none, 1 = rain, 2 = hail,  3 = rain + hail (experimental))<br>14 - Average Strike Distance (km)<br>15 - Strike Count<br>16 - Battery (volts)<br>17 - Report Interval (minutes)<br>18 - Local Day Rain Accumulation (mm)<br>19 - <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>20 - Local Day <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>21 - Precipitation Aanalysis Type (0 = none, 1 = Rain Check with user display on, 2 = Rain Check with user display off)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_observations_by_device_id(device_id, day_offset, time_start, time_end, format, async_req=True)
        >>> result = thread.get()

        :param device_id: ID of device (required)
        :type device_id: int
        :param day_offset: TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC
        :type day_offset: int
        :param time_start: TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.
        :type time_start: int
        :param time_end: TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.
        :type time_end: int
        :param format: Use format=csv to return a CSV response type.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ObservationSet
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_observations_by_device_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_observations_by_device_id_with_http_info(device_id, day_offset, time_start, time_end, format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_observations_by_device_id_with_http_info(self, device_id : Annotated[StrictInt, Field(..., description="ID of device")], day_offset : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC")] = None, time_start : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, time_end : Annotated[Optional[StrictInt], Field(description="TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.")] = None, format : Annotated[Optional[StrictStr], Field(description="Use format=csv to return a CSV response type.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Observations for a Single Device  # noqa: E501

        Get observations for a Device(Air,Sky,Tempest) by using the device_id as the key.  You can find device_id values in the response from the Stations service  You can get observations using several filters (latest, time range, day offset).      Use the \"type\" value to determine the layout of the observations values.  The \"obs\" object is an array of observations.  Each observation is an array of observation values (see layout below).<br><br>**Air**  (type=\"obs_air\")<br>Observation Layout<br>0 - Epoch (seconds UTC)<br>1 - Station Pressure (MB)<br>2 - Air Temperature (C)<br>3 - Relative Humidity (%)<br>4 - Lightning Strike Count<br>5 - Lightning Strike Average Distance (km)<br>6 - Battery (volts)<br>7 - Report Interval (minutes)<br><br>**Sky** (type=\"obs_sky\")<br>Observation Layout<br>0 - Epoch (seconds UTC)<br>1 - Illuminance (lux)<br>2 - UV (index)<br>3 - Rain Accumulation (mm)<br>4 - Wind Lull  (m/s)<br>5 - Wind Avg (m/s)<br>6 - Wind Gust (m/s)<br>7 - Wind Direction (degrees)<br>8 - Battery (volts)<br>9 - Report Interval (minutes)<br>10 - Solar Radiation (W/m^2)<br>11 - Local Day Rain Accumulation (mm)<br>12 - Precipitation Type (0 = none, 1 = rain, 2 = hail, 3 = rain + hail (experimental))<br>13 - Wind Sample Interval (seconds)<br>14 - <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> (mm)<br>15 - Local Day <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>16 - Precipitation Analysis Type (0 = none, 1 = Rain Check with user display on, 2 = Rain Check with user display off)<br><br>**Tempest** (type=\"obs_st\")<br>Observation Layout<br>0 - Epoch (Seconds UTC)<br>1 - Wind Lull  (m/s)<br>2 - Wind Avg (m/s)<br>3 - Wind Gust (m/s)<br>4 - Wind Direction (degrees)<br>5 - Wind Sample Interval (seconds)<br>6 - Pressure (MB)<br>7 - Air Temperature (C)<br>8 - Relative Humidity (%)<br>9 - Illuminance (lux)<br>10 - UV (index)<br>11 - Solar Radiation (W/m^2)<br>12 - Rain Accumulation (mm)<br>13 - Precipitation Type (0 = none, 1 = rain, 2 = hail,  3 = rain + hail (experimental))<br>14 - Average Strike Distance (km)<br>15 - Strike Count<br>16 - Battery (volts)<br>17 - Report Interval (minutes)<br>18 - Local Day Rain Accumulation (mm)<br>19 - <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>20 - Local Day <a href='https://help.weatherflow.com/hc/en-us/articles/360024436634' target='_blank'>NC Rain</a> Accumulation (mm)<br>21 - Precipitation Aanalysis Type (0 = none, 1 = Rain Check with user display on, 2 = Rain Check with user display off)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_observations_by_device_id_with_http_info(device_id, day_offset, time_start, time_end, format, async_req=True)
        >>> result = thread.get()

        :param device_id: ID of device (required)
        :type device_id: int
        :param day_offset: TIME FILTER - Get an entire day of observations by UTC day offset.<br><br>0 - Current day UTC<br>1 - Yesterday UTC
        :type day_offset: int
        :param time_start: TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_end\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.
        :type time_start: int
        :param time_end: TIME FILTER - Time range start time epoch seconds UTC.  Observation data at a one minute time resolution is available for a time range that is five days or less.  You also need to send \"time_start\".  This field pair is optional.  If the request does not contain any time filters only the latest observation will be returned.
        :type time_end: int
        :param format: Use format=csv to return a CSV response type.
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ObservationSet, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'device_id',
            'day_offset',
            'time_start',
            'time_end',
            'format'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_observations_by_device_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['device_id']:
            _path_params['device_id'] = _params['device_id']


        # process the query parameters
        _query_params = []
        if _params.get('day_offset') is not None:  # noqa: E501
            _query_params.append(('day_offset', _params['day_offset']))

        if _params.get('time_start') is not None:  # noqa: E501
            _query_params.append(('time_start', _params['time_start']))

        if _params.get('time_end') is not None:  # noqa: E501
            _query_params.append(('time_end', _params['time_end']))

        if _params.get('format') is not None:  # noqa: E501
            _query_params.append(('format', _params['format']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['swdApiKey', 'swdImplicit']  # noqa: E501

        _response_types_map = {
            '200': "ObservationSet",
            '404': None,
        }

        return self.api_client.call_api(
            '/observations/device/{device_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_station_observation(self, station_id : Annotated[StrictInt, Field(..., description="ID of Station to return")], **kwargs) -> StationObservation:  # noqa: E501
        ...

    @overload
    def get_station_observation(self, station_id : Annotated[StrictInt, Field(..., description="ID of Station to return")], async_req: Optional[bool]=True, **kwargs) -> StationObservation:  # noqa: E501
        ...

    @validate_arguments
    def get_station_observation(self, station_id : Annotated[StrictInt, Field(..., description="ID of Station to return")], async_req: Optional[bool]=None, **kwargs) -> Union[StationObservation, Awaitable[StationObservation]]:  # noqa: E501
        """Get the latest Station observation  # noqa: E501

        Get the latest federated observation for a Station.  This observation is made from the latest Device observations that belong to the Station.  If a user has multiple Devices of the same type they are able to designate one of them as primary. This is the one used to make the federated observation.<br><br>A user can also designate each device as either indoor or outdoor.  All indoor observation value fields will end with an \"_indoor\" suffix.  Outdoor observations fields do not have a suffix.<br><br>The station_units values represent the units of the Station's owner, not the units of the observation values in the API response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_station_observation(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: ID of Station to return (required)
        :type station_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StationObservation
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_station_observation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_station_observation_with_http_info(station_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_station_observation_with_http_info(self, station_id : Annotated[StrictInt, Field(..., description="ID of Station to return")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get the latest Station observation  # noqa: E501

        Get the latest federated observation for a Station.  This observation is made from the latest Device observations that belong to the Station.  If a user has multiple Devices of the same type they are able to designate one of them as primary. This is the one used to make the federated observation.<br><br>A user can also designate each device as either indoor or outdoor.  All indoor observation value fields will end with an \"_indoor\" suffix.  Outdoor observations fields do not have a suffix.<br><br>The station_units values represent the units of the Station's owner, not the units of the observation values in the API response.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_station_observation_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: ID of Station to return (required)
        :type station_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StationObservation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'station_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_station_observation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['station_id']:
            _path_params['station_id'] = _params['station_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['swdApiKey', 'swdImplicit']  # noqa: E501

        _response_types_map = {
            '200': "StationObservation",
            '404': None,
        }

        return self.api_client.call_api(
            '/observations/station/{station_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
